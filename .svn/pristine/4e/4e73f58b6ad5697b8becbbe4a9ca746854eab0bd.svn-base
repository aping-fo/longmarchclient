(function() {"use strict";var __module = CC_EDITOR ? module : {exports:{}};var __filename = 'preview-scripts/assets/scripts/tools/UIHelper.js';var __require = CC_EDITOR ? function (request) {return cc.require(request, require);} : function (request) {return cc.require(request, __filename);};function __define (exports, require, module) {"use strict";
cc._RF.push(module, '1b31fj8qTRLwo6NbJrRFKo8', 'UIHelper', __filename);
// scripts/tools/UIHelper.js

"use strict";

var WXTool = require("WXTool");

function SetLastSiblingIndex(node, parent) {
    if (parent == null) {
        parent = node.parent;
    }

    var lastIndex = 0;
    for (var i = 0; i < parent.children.length; i++) {
        lastIndex = Math.max(lastIndex, parent.children[i].getSiblingIndex());
    }

    node.setSiblingIndex(lastIndex + 1);
}

function GetCaptureCamera() {
    var captureCameraNode = cc.find("CaptureCamera", cc.Canvas.instance.node);
    if (captureCameraNode == null) {
        var captureCameraNode = new cc.Node();
        captureCameraNode.setParent(cc.Canvas.instance.node);

        var captureCamera = captureCameraNode.addComponent(cc.Camera);
        captureCamera.cullingMask = 0x00000002;

        captureCameraNode.active = false;
        captureCameraNode.name = "CaptureCamera";
        captureCameraNode.position = cc.Vec2.ZERO;
    }
    return captureCameraNode.getComponent(cc.Camera);
}

function SetImageFromUrl(sprite, url, isRemote) {
    if (url == "") {
        sprite.spriteFrame = null;
        return;
    }

    if (isRemote == null) {
        isRemote = false;
    }

    if (isRemote) {
        url += "?aaa=aa.jpg";
        // console.log("load image" + url);
        cc.loader.load(url, function (err, tex) {
            if (err) {
                cc.error(err.message || err);
                return;
            }
            sprite.spriteFrame = new cc.SpriteFrame(tex);
        });
    } else {
        cc.loader.loadRes(url, cc.SpriteFrame, function (err, spriteFrame) {
            if (err) {
                cc.error(err.message || err);
                return;
            }
            sprite.spriteFrame = spriteFrame;
        });
    }
}

//保存节点的图片
function SaveNodeRender(node, pageHeigth, isStore, callback) {
    if (!WXTool.enable) {
        if (callback) {
            callback("");
        }
        return;
    }

    var oldPosition = node.position;
    var oldActive = node.active;
    node.active = true;

    var worldBoundingBox = node.getBoundingBoxToWorld();
    // pageHeigth = Math.min(pageHeigth, worldBoundingBox.height);

    var captureCamera = GetCaptureCamera();

    var width = cc.winSize.width;
    var height = cc.winSize.height;

    captureCamera.node.active = true;

    //截屏renderTexture
    var renderTexture = new cc.RenderTexture();
    renderTexture.initWithSize(width, height);

    captureCamera.targetTexture = renderTexture;

    var canvas = wx.createCanvas();
    var ctx = canvas.getContext("2d");
    var saveHeight = worldBoundingBox.height;
    canvas.width = worldBoundingBox.width;
    canvas.height = saveHeight;

    var rowBytes = 4 * worldBoundingBox.width;
    var page = Math.ceil(saveHeight / pageHeigth); //如果比屏幕大，则多次截屏保存成1张

    for (var i = 0; i < page; i++) {
        //渲染
        captureCamera.render();

        //读取数据
        var data = renderTexture.readPixels(null, worldBoundingBox.x, 0, worldBoundingBox.width, pageHeigth);
        var beginRow = i * pageHeigth;
        var endRow = Math.min(beginRow + pageHeigth, saveHeight);

        for (var row = beginRow; row < endRow; row++) {
            var srow = endRow - 1 - row;
            var imageData = ctx.createImageData(width, 1);
            var start = srow * rowBytes;
            for (var _i = 0; _i < rowBytes; _i++) {
                imageData.data[_i] = data[start + _i];
            }
            ctx.putImageData(imageData, 0, row);
        }
        node.position = new cc.Vec2(node.position.x, node.position.y + pageHeigth);

        renderTexture.destroy();
        renderTexture = new cc.RenderTexture();
        renderTexture.initWithSize(width, height);
        captureCamera.targetTexture = renderTexture;
    }
    node.position = oldPosition;
    node.active = oldActive;

    captureCamera.node.active = false;
    captureCamera.targetTexture = null;

    renderTexture.destroy();

    var path = canvas.toTempFilePathSync();
    if (isStore) {
        WXTool.getInstance().saveFileToLocal(path, function (res, path) {
            if (res == "success") {
                if (callback) {
                    callback(path);
                }
            }
        });
    } else {
        if (callback) {
            callback(path);
        }
    }
}

//保存画布
function SaveCanvas(withoutNodes, isStore, callback) {
    if (!WXTool.enable) {
        if (callback) {
            callback("");
        }
        return;
    }

    var visibleStatus = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = withoutNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            visibleStatus.push(node.active);
            node.active = false;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    cc.renderer.render(cc.director.getScene());
    var path = cc.game.canvas.toTempFilePathSync();
    if (isStore) {
        WXTool.getInstance().saveFileToLocal(path, function (res, path) {
            if (res == "success") {
                if (callback) {
                    callback(path);
                }
            }
            for (var i in withoutNodes) {
                withoutNodes[i].active = visibleStatus[i];
            }
        });
    } else {
        if (callback) {
            callback(path);
        }
        for (var i in withoutNodes) {
            withoutNodes[i].active = visibleStatus[i];
        }
    }
}

module.exports = {
    SetLastSiblingIndex: SetLastSiblingIndex,
    SetImageFromUrl: SetImageFromUrl,
    SaveNodeRender: SaveNodeRender,
    SaveCanvas: SaveCanvas
};

cc._RF.pop();
        }
        if (CC_EDITOR) {
            __define(__module.exports, __require, __module);
        }
        else {
            cc.registerModuleFunc(__filename, function () {
                __define(__module.exports, __require, __module);
            });
        }
        })();
        //# sourceMappingURL=UIHelper.js.map
        